// Code generated by capnpc-go. DO NOT EDIT.

package writecapnp

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	fc "capnproto.org/go/capnp/v3/flowcontrol"
	schemas "capnproto.org/go/capnp/v3/schemas"
	server "capnproto.org/go/capnp/v3/server"
	context "context"
	math "math"
	strconv "strconv"
)

type Symbols capnp.Struct

// Symbols_TypeID is the unique identifier for the type Symbols.
const Symbols_TypeID = 0xab79e1a6ecfeb87a

func NewSymbols(s *capnp.Segment) (Symbols, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Symbols(st), err
}

func NewRootSymbols(s *capnp.Segment) (Symbols, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Symbols(st), err
}

func ReadRootSymbols(msg *capnp.Message) (Symbols, error) {
	root, err := msg.Root()
	return Symbols(root.Struct()), err
}

func (s Symbols) String() string {
	str, _ := text.Marshal(0xab79e1a6ecfeb87a, capnp.Struct(s))
	return str
}

func (s Symbols) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Symbols) DecodeFromPtr(p capnp.Ptr) Symbols {
	return Symbols(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Symbols) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Symbols) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Symbols) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Symbols) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Symbols) Items() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.TextList(p.List()), err
}

func (s Symbols) HasItems() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Symbols) SetItems(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewItems sets the items field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s Symbols) NewItems(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// Symbols_List is a list of Symbols.
type Symbols_List = capnp.StructList[Symbols]

// NewSymbols creates a new list of Symbols.
func NewSymbols_List(s *capnp.Segment, sz int32) (Symbols_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Symbols](l), err
}

// Symbols_Future is a wrapper for a Symbols promised by a client call.
type Symbols_Future struct{ *capnp.Future }

func (f Symbols_Future) Struct() (Symbols, error) {
	p, err := f.Future.Ptr()
	return Symbols(p.Struct()), err
}

type Label capnp.Struct

// Label_TypeID is the unique identifier for the type Label.
const Label_TypeID = 0xf192c7ee07114b32

func NewLabel(s *capnp.Segment) (Label, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Label(st), err
}

func NewRootLabel(s *capnp.Segment) (Label, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Label(st), err
}

func ReadRootLabel(msg *capnp.Message) (Label, error) {
	root, err := msg.Root()
	return Label(root.Struct()), err
}

func (s Label) String() string {
	str, _ := text.Marshal(0xf192c7ee07114b32, capnp.Struct(s))
	return str
}

func (s Label) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Label) DecodeFromPtr(p capnp.Ptr) Label {
	return Label(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Label) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Label) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Label) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Label) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Label) Name() uint32 {
	return capnp.Struct(s).Uint32(0)
}

func (s Label) SetName(v uint32) {
	capnp.Struct(s).SetUint32(0, v)
}

func (s Label) Value() uint32 {
	return capnp.Struct(s).Uint32(4)
}

func (s Label) SetValue(v uint32) {
	capnp.Struct(s).SetUint32(4, v)
}

// Label_List is a list of Label.
type Label_List = capnp.StructList[Label]

// NewLabel creates a new list of Label.
func NewLabel_List(s *capnp.Segment, sz int32) (Label_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[Label](l), err
}

// Label_Future is a wrapper for a Label promised by a client call.
type Label_Future struct{ *capnp.Future }

func (f Label_Future) Struct() (Label, error) {
	p, err := f.Future.Ptr()
	return Label(p.Struct()), err
}

type Sample capnp.Struct

// Sample_TypeID is the unique identifier for the type Sample.
const Sample_TypeID = 0xef49df6cfa8875de

func NewSample(s *capnp.Segment) (Sample, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Sample(st), err
}

func NewRootSample(s *capnp.Segment) (Sample, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Sample(st), err
}

func ReadRootSample(msg *capnp.Message) (Sample, error) {
	root, err := msg.Root()
	return Sample(root.Struct()), err
}

func (s Sample) String() string {
	str, _ := text.Marshal(0xef49df6cfa8875de, capnp.Struct(s))
	return str
}

func (s Sample) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Sample) DecodeFromPtr(p capnp.Ptr) Sample {
	return Sample(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Sample) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Sample) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Sample) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Sample) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Sample) Timestamp() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s Sample) SetTimestamp(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

func (s Sample) Value() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s Sample) SetValue(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

// Sample_List is a list of Sample.
type Sample_List = capnp.StructList[Sample]

// NewSample creates a new list of Sample.
func NewSample_List(s *capnp.Segment, sz int32) (Sample_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0}, sz)
	return capnp.StructList[Sample](l), err
}

// Sample_Future is a wrapper for a Sample promised by a client call.
type Sample_Future struct{ *capnp.Future }

func (f Sample_Future) Struct() (Sample, error) {
	p, err := f.Future.Ptr()
	return Sample(p.Struct()), err
}

type BucketSpan capnp.Struct

// BucketSpan_TypeID is the unique identifier for the type BucketSpan.
const BucketSpan_TypeID = 0x983649d193295eae

func NewBucketSpan(s *capnp.Segment) (BucketSpan, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return BucketSpan(st), err
}

func NewRootBucketSpan(s *capnp.Segment) (BucketSpan, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return BucketSpan(st), err
}

func ReadRootBucketSpan(msg *capnp.Message) (BucketSpan, error) {
	root, err := msg.Root()
	return BucketSpan(root.Struct()), err
}

func (s BucketSpan) String() string {
	str, _ := text.Marshal(0x983649d193295eae, capnp.Struct(s))
	return str
}

func (s BucketSpan) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (BucketSpan) DecodeFromPtr(p capnp.Ptr) BucketSpan {
	return BucketSpan(capnp.Struct{}.DecodeFromPtr(p))
}

func (s BucketSpan) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s BucketSpan) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s BucketSpan) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s BucketSpan) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s BucketSpan) Offset() int32 {
	return int32(capnp.Struct(s).Uint32(0))
}

func (s BucketSpan) SetOffset(v int32) {
	capnp.Struct(s).SetUint32(0, uint32(v))
}

func (s BucketSpan) Length() uint32 {
	return capnp.Struct(s).Uint32(4)
}

func (s BucketSpan) SetLength(v uint32) {
	capnp.Struct(s).SetUint32(4, v)
}

// BucketSpan_List is a list of BucketSpan.
type BucketSpan_List = capnp.StructList[BucketSpan]

// NewBucketSpan creates a new list of BucketSpan.
func NewBucketSpan_List(s *capnp.Segment, sz int32) (BucketSpan_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[BucketSpan](l), err
}

// BucketSpan_Future is a wrapper for a BucketSpan promised by a client call.
type BucketSpan_Future struct{ *capnp.Future }

func (f BucketSpan_Future) Struct() (BucketSpan, error) {
	p, err := f.Future.Ptr()
	return BucketSpan(p.Struct()), err
}

type Histogram capnp.Struct
type Histogram_count Histogram
type Histogram_zeroCount Histogram
type Histogram_count_Which uint16

const (
	Histogram_count_Which_countInt   Histogram_count_Which = 0
	Histogram_count_Which_countFloat Histogram_count_Which = 1
)

func (w Histogram_count_Which) String() string {
	const s = "countIntcountFloat"
	switch w {
	case Histogram_count_Which_countInt:
		return s[0:8]
	case Histogram_count_Which_countFloat:
		return s[8:18]

	}
	return "Histogram_count_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

type Histogram_zeroCount_Which uint16

const (
	Histogram_zeroCount_Which_zeroCountInt   Histogram_zeroCount_Which = 0
	Histogram_zeroCount_Which_zeroCountFloat Histogram_zeroCount_Which = 1
)

func (w Histogram_zeroCount_Which) String() string {
	const s = "zeroCountIntzeroCountFloat"
	switch w {
	case Histogram_zeroCount_Which_zeroCountInt:
		return s[0:12]
	case Histogram_zeroCount_Which_zeroCountFloat:
		return s[12:26]

	}
	return "Histogram_zeroCount_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Histogram_TypeID is the unique identifier for the type Histogram.
const Histogram_TypeID = 0xc4dd3c458256382a

func NewHistogram(s *capnp.Segment) (Histogram, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 56, PointerCount: 6})
	return Histogram(st), err
}

func NewRootHistogram(s *capnp.Segment) (Histogram, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 56, PointerCount: 6})
	return Histogram(st), err
}

func ReadRootHistogram(msg *capnp.Message) (Histogram, error) {
	root, err := msg.Root()
	return Histogram(root.Struct()), err
}

func (s Histogram) String() string {
	str, _ := text.Marshal(0xc4dd3c458256382a, capnp.Struct(s))
	return str
}

func (s Histogram) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Histogram) DecodeFromPtr(p capnp.Ptr) Histogram {
	return Histogram(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Histogram) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Histogram) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Histogram) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Histogram) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Histogram) Count() Histogram_count { return Histogram_count(s) }

func (s Histogram_count) Which() Histogram_count_Which {
	return Histogram_count_Which(capnp.Struct(s).Uint16(8))
}
func (s Histogram_count) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Histogram_count) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Histogram_count) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Histogram_count) CountInt() uint64 {
	if capnp.Struct(s).Uint16(8) != 0 {
		panic("Which() != countInt")
	}
	return capnp.Struct(s).Uint64(0)
}

func (s Histogram_count) SetCountInt(v uint64) {
	capnp.Struct(s).SetUint16(8, 0)
	capnp.Struct(s).SetUint64(0, v)
}

func (s Histogram_count) CountFloat() float64 {
	if capnp.Struct(s).Uint16(8) != 1 {
		panic("Which() != countFloat")
	}
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s Histogram_count) SetCountFloat(v float64) {
	capnp.Struct(s).SetUint16(8, 1)
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s Histogram) Sum() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(16))
}

func (s Histogram) SetSum(v float64) {
	capnp.Struct(s).SetUint64(16, math.Float64bits(v))
}

func (s Histogram) Schema() int32 {
	return int32(capnp.Struct(s).Uint32(12))
}

func (s Histogram) SetSchema(v int32) {
	capnp.Struct(s).SetUint32(12, uint32(v))
}

func (s Histogram) ZeroThreshold() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(24))
}

func (s Histogram) SetZeroThreshold(v float64) {
	capnp.Struct(s).SetUint64(24, math.Float64bits(v))
}

func (s Histogram) ZeroCount() Histogram_zeroCount { return Histogram_zeroCount(s) }

func (s Histogram_zeroCount) Which() Histogram_zeroCount_Which {
	return Histogram_zeroCount_Which(capnp.Struct(s).Uint16(10))
}
func (s Histogram_zeroCount) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Histogram_zeroCount) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Histogram_zeroCount) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Histogram_zeroCount) ZeroCountInt() uint64 {
	if capnp.Struct(s).Uint16(10) != 0 {
		panic("Which() != zeroCountInt")
	}
	return capnp.Struct(s).Uint64(32)
}

func (s Histogram_zeroCount) SetZeroCountInt(v uint64) {
	capnp.Struct(s).SetUint16(10, 0)
	capnp.Struct(s).SetUint64(32, v)
}

func (s Histogram_zeroCount) ZeroCountFloat() float64 {
	if capnp.Struct(s).Uint16(10) != 1 {
		panic("Which() != zeroCountFloat")
	}
	return math.Float64frombits(capnp.Struct(s).Uint64(32))
}

func (s Histogram_zeroCount) SetZeroCountFloat(v float64) {
	capnp.Struct(s).SetUint16(10, 1)
	capnp.Struct(s).SetUint64(32, math.Float64bits(v))
}

func (s Histogram) NegativeSpans() (BucketSpan_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return BucketSpan_List(p.List()), err
}

func (s Histogram) HasNegativeSpans() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Histogram) SetNegativeSpans(v BucketSpan_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewNegativeSpans sets the negativeSpans field to a newly
// allocated BucketSpan_List, preferring placement in s's segment.
func (s Histogram) NewNegativeSpans(n int32) (BucketSpan_List, error) {
	l, err := NewBucketSpan_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return BucketSpan_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Histogram) NegativeDeltas() (capnp.Int64List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return capnp.Int64List(p.List()), err
}

func (s Histogram) HasNegativeDeltas() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Histogram) SetNegativeDeltas(v capnp.Int64List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewNegativeDeltas sets the negativeDeltas field to a newly
// allocated capnp.Int64List, preferring placement in s's segment.
func (s Histogram) NewNegativeDeltas(n int32) (capnp.Int64List, error) {
	l, err := capnp.NewInt64List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.Int64List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s Histogram) NegativeCounts() (capnp.Float64List, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return capnp.Float64List(p.List()), err
}

func (s Histogram) HasNegativeCounts() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Histogram) SetNegativeCounts(v capnp.Float64List) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewNegativeCounts sets the negativeCounts field to a newly
// allocated capnp.Float64List, preferring placement in s's segment.
func (s Histogram) NewNegativeCounts(n int32) (capnp.Float64List, error) {
	l, err := capnp.NewFloat64List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.Float64List{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}
func (s Histogram) PositiveSpans() (BucketSpan_List, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return BucketSpan_List(p.List()), err
}

func (s Histogram) HasPositiveSpans() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s Histogram) SetPositiveSpans(v BucketSpan_List) error {
	return capnp.Struct(s).SetPtr(3, v.ToPtr())
}

// NewPositiveSpans sets the positiveSpans field to a newly
// allocated BucketSpan_List, preferring placement in s's segment.
func (s Histogram) NewPositiveSpans(n int32) (BucketSpan_List, error) {
	l, err := NewBucketSpan_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return BucketSpan_List{}, err
	}
	err = capnp.Struct(s).SetPtr(3, l.ToPtr())
	return l, err
}
func (s Histogram) PositiveDeltas() (capnp.Int64List, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return capnp.Int64List(p.List()), err
}

func (s Histogram) HasPositiveDeltas() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s Histogram) SetPositiveDeltas(v capnp.Int64List) error {
	return capnp.Struct(s).SetPtr(4, v.ToPtr())
}

// NewPositiveDeltas sets the positiveDeltas field to a newly
// allocated capnp.Int64List, preferring placement in s's segment.
func (s Histogram) NewPositiveDeltas(n int32) (capnp.Int64List, error) {
	l, err := capnp.NewInt64List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.Int64List{}, err
	}
	err = capnp.Struct(s).SetPtr(4, l.ToPtr())
	return l, err
}
func (s Histogram) PositiveCounts() (capnp.Float64List, error) {
	p, err := capnp.Struct(s).Ptr(5)
	return capnp.Float64List(p.List()), err
}

func (s Histogram) HasPositiveCounts() bool {
	return capnp.Struct(s).HasPtr(5)
}

func (s Histogram) SetPositiveCounts(v capnp.Float64List) error {
	return capnp.Struct(s).SetPtr(5, v.ToPtr())
}

// NewPositiveCounts sets the positiveCounts field to a newly
// allocated capnp.Float64List, preferring placement in s's segment.
func (s Histogram) NewPositiveCounts(n int32) (capnp.Float64List, error) {
	l, err := capnp.NewFloat64List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.Float64List{}, err
	}
	err = capnp.Struct(s).SetPtr(5, l.ToPtr())
	return l, err
}
func (s Histogram) ResetHint() Histogram_ResetHint {
	return Histogram_ResetHint(capnp.Struct(s).Uint16(40))
}

func (s Histogram) SetResetHint(v Histogram_ResetHint) {
	capnp.Struct(s).SetUint16(40, uint16(v))
}

func (s Histogram) Timestamp() int64 {
	return int64(capnp.Struct(s).Uint64(48))
}

func (s Histogram) SetTimestamp(v int64) {
	capnp.Struct(s).SetUint64(48, uint64(v))
}

// Histogram_List is a list of Histogram.
type Histogram_List = capnp.StructList[Histogram]

// NewHistogram creates a new list of Histogram.
func NewHistogram_List(s *capnp.Segment, sz int32) (Histogram_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 56, PointerCount: 6}, sz)
	return capnp.StructList[Histogram](l), err
}

// Histogram_Future is a wrapper for a Histogram promised by a client call.
type Histogram_Future struct{ *capnp.Future }

func (f Histogram_Future) Struct() (Histogram, error) {
	p, err := f.Future.Ptr()
	return Histogram(p.Struct()), err
}
func (p Histogram_Future) Count() Histogram_count_Future { return Histogram_count_Future{p.Future} }

// Histogram_count_Future is a wrapper for a Histogram_count promised by a client call.
type Histogram_count_Future struct{ *capnp.Future }

func (f Histogram_count_Future) Struct() (Histogram_count, error) {
	p, err := f.Future.Ptr()
	return Histogram_count(p.Struct()), err
}
func (p Histogram_Future) ZeroCount() Histogram_zeroCount_Future {
	return Histogram_zeroCount_Future{p.Future}
}

// Histogram_zeroCount_Future is a wrapper for a Histogram_zeroCount promised by a client call.
type Histogram_zeroCount_Future struct{ *capnp.Future }

func (f Histogram_zeroCount_Future) Struct() (Histogram_zeroCount, error) {
	p, err := f.Future.Ptr()
	return Histogram_zeroCount(p.Struct()), err
}

type Histogram_ResetHint uint16

// Histogram_ResetHint_TypeID is the unique identifier for the type Histogram_ResetHint.
const Histogram_ResetHint_TypeID = 0xd5b0cec646441eb0

// Values of Histogram_ResetHint.
const (
	Histogram_ResetHint_unknown Histogram_ResetHint = 0
	Histogram_ResetHint_yes     Histogram_ResetHint = 1
	Histogram_ResetHint_no      Histogram_ResetHint = 2
	Histogram_ResetHint_gauge   Histogram_ResetHint = 3
)

// String returns the enum's constant name.
func (c Histogram_ResetHint) String() string {
	switch c {
	case Histogram_ResetHint_unknown:
		return "unknown"
	case Histogram_ResetHint_yes:
		return "yes"
	case Histogram_ResetHint_no:
		return "no"
	case Histogram_ResetHint_gauge:
		return "gauge"

	default:
		return ""
	}
}

// Histogram_ResetHintFromString returns the enum value with a name,
// or the zero value if there's no such value.
func Histogram_ResetHintFromString(c string) Histogram_ResetHint {
	switch c {
	case "unknown":
		return Histogram_ResetHint_unknown
	case "yes":
		return Histogram_ResetHint_yes
	case "no":
		return Histogram_ResetHint_no
	case "gauge":
		return Histogram_ResetHint_gauge

	default:
		return 0
	}
}

type Histogram_ResetHint_List = capnp.EnumList[Histogram_ResetHint]

func NewHistogram_ResetHint_List(s *capnp.Segment, sz int32) (Histogram_ResetHint_List, error) {
	return capnp.NewEnumList[Histogram_ResetHint](s, sz)
}

type Exemplar capnp.Struct

// Exemplar_TypeID is the unique identifier for the type Exemplar.
const Exemplar_TypeID = 0xbd820120399954be

func NewExemplar(s *capnp.Segment) (Exemplar, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return Exemplar(st), err
}

func NewRootExemplar(s *capnp.Segment) (Exemplar, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return Exemplar(st), err
}

func ReadRootExemplar(msg *capnp.Message) (Exemplar, error) {
	root, err := msg.Root()
	return Exemplar(root.Struct()), err
}

func (s Exemplar) String() string {
	str, _ := text.Marshal(0xbd820120399954be, capnp.Struct(s))
	return str
}

func (s Exemplar) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Exemplar) DecodeFromPtr(p capnp.Ptr) Exemplar {
	return Exemplar(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Exemplar) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Exemplar) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Exemplar) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Exemplar) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Exemplar) Labels() (Label_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Label_List(p.List()), err
}

func (s Exemplar) HasLabels() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Exemplar) SetLabels(v Label_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewLabels sets the labels field to a newly
// allocated Label_List, preferring placement in s's segment.
func (s Exemplar) NewLabels(n int32) (Label_List, error) {
	l, err := NewLabel_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Label_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Exemplar) Value() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s Exemplar) SetValue(v float64) {
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s Exemplar) Timestamp() int64 {
	return int64(capnp.Struct(s).Uint64(8))
}

func (s Exemplar) SetTimestamp(v int64) {
	capnp.Struct(s).SetUint64(8, uint64(v))
}

// Exemplar_List is a list of Exemplar.
type Exemplar_List = capnp.StructList[Exemplar]

// NewExemplar creates a new list of Exemplar.
func NewExemplar_List(s *capnp.Segment, sz int32) (Exemplar_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1}, sz)
	return capnp.StructList[Exemplar](l), err
}

// Exemplar_Future is a wrapper for a Exemplar promised by a client call.
type Exemplar_Future struct{ *capnp.Future }

func (f Exemplar_Future) Struct() (Exemplar, error) {
	p, err := f.Future.Ptr()
	return Exemplar(p.Struct()), err
}

type TimeSeries capnp.Struct

// TimeSeries_TypeID is the unique identifier for the type TimeSeries.
const TimeSeries_TypeID = 0xb438c10228b97446

func NewTimeSeries(s *capnp.Segment) (TimeSeries, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 4})
	return TimeSeries(st), err
}

func NewRootTimeSeries(s *capnp.Segment) (TimeSeries, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 4})
	return TimeSeries(st), err
}

func ReadRootTimeSeries(msg *capnp.Message) (TimeSeries, error) {
	root, err := msg.Root()
	return TimeSeries(root.Struct()), err
}

func (s TimeSeries) String() string {
	str, _ := text.Marshal(0xb438c10228b97446, capnp.Struct(s))
	return str
}

func (s TimeSeries) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (TimeSeries) DecodeFromPtr(p capnp.Ptr) TimeSeries {
	return TimeSeries(capnp.Struct{}.DecodeFromPtr(p))
}

func (s TimeSeries) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s TimeSeries) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s TimeSeries) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s TimeSeries) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s TimeSeries) Labels() (Label_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Label_List(p.List()), err
}

func (s TimeSeries) HasLabels() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s TimeSeries) SetLabels(v Label_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewLabels sets the labels field to a newly
// allocated Label_List, preferring placement in s's segment.
func (s TimeSeries) NewLabels(n int32) (Label_List, error) {
	l, err := NewLabel_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Label_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s TimeSeries) Samples() (Sample_List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return Sample_List(p.List()), err
}

func (s TimeSeries) HasSamples() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s TimeSeries) SetSamples(v Sample_List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewSamples sets the samples field to a newly
// allocated Sample_List, preferring placement in s's segment.
func (s TimeSeries) NewSamples(n int32) (Sample_List, error) {
	l, err := NewSample_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Sample_List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s TimeSeries) Histograms() (Histogram_List, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return Histogram_List(p.List()), err
}

func (s TimeSeries) HasHistograms() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s TimeSeries) SetHistograms(v Histogram_List) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewHistograms sets the histograms field to a newly
// allocated Histogram_List, preferring placement in s's segment.
func (s TimeSeries) NewHistograms(n int32) (Histogram_List, error) {
	l, err := NewHistogram_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Histogram_List{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}
func (s TimeSeries) Exemplars() (Exemplar_List, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return Exemplar_List(p.List()), err
}

func (s TimeSeries) HasExemplars() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s TimeSeries) SetExemplars(v Exemplar_List) error {
	return capnp.Struct(s).SetPtr(3, v.ToPtr())
}

// NewExemplars sets the exemplars field to a newly
// allocated Exemplar_List, preferring placement in s's segment.
func (s TimeSeries) NewExemplars(n int32) (Exemplar_List, error) {
	l, err := NewExemplar_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Exemplar_List{}, err
	}
	err = capnp.Struct(s).SetPtr(3, l.ToPtr())
	return l, err
}

// TimeSeries_List is a list of TimeSeries.
type TimeSeries_List = capnp.StructList[TimeSeries]

// NewTimeSeries creates a new list of TimeSeries.
func NewTimeSeries_List(s *capnp.Segment, sz int32) (TimeSeries_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 4}, sz)
	return capnp.StructList[TimeSeries](l), err
}

// TimeSeries_Future is a wrapper for a TimeSeries promised by a client call.
type TimeSeries_Future struct{ *capnp.Future }

func (f TimeSeries_Future) Struct() (TimeSeries, error) {
	p, err := f.Future.Ptr()
	return TimeSeries(p.Struct()), err
}

type WriteRequest capnp.Struct

// WriteRequest_TypeID is the unique identifier for the type WriteRequest.
const WriteRequest_TypeID = 0xeb3bcb770c8eb6be

func NewWriteRequest(s *capnp.Segment) (WriteRequest, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return WriteRequest(st), err
}

func NewRootWriteRequest(s *capnp.Segment) (WriteRequest, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return WriteRequest(st), err
}

func ReadRootWriteRequest(msg *capnp.Message) (WriteRequest, error) {
	root, err := msg.Root()
	return WriteRequest(root.Struct()), err
}

func (s WriteRequest) String() string {
	str, _ := text.Marshal(0xeb3bcb770c8eb6be, capnp.Struct(s))
	return str
}

func (s WriteRequest) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (WriteRequest) DecodeFromPtr(p capnp.Ptr) WriteRequest {
	return WriteRequest(capnp.Struct{}.DecodeFromPtr(p))
}

func (s WriteRequest) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s WriteRequest) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s WriteRequest) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s WriteRequest) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s WriteRequest) Symbols() (Symbols, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Symbols(p.Struct()), err
}

func (s WriteRequest) HasSymbols() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s WriteRequest) SetSymbols(v Symbols) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewSymbols sets the symbols field to a newly
// allocated Symbols struct, preferring placement in s's segment.
func (s WriteRequest) NewSymbols() (Symbols, error) {
	ss, err := NewSymbols(capnp.Struct(s).Segment())
	if err != nil {
		return Symbols{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s WriteRequest) TimeSeries() (TimeSeries_List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return TimeSeries_List(p.List()), err
}

func (s WriteRequest) HasTimeSeries() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s WriteRequest) SetTimeSeries(v TimeSeries_List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewTimeSeries sets the timeSeries field to a newly
// allocated TimeSeries_List, preferring placement in s's segment.
func (s WriteRequest) NewTimeSeries(n int32) (TimeSeries_List, error) {
	l, err := NewTimeSeries_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return TimeSeries_List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s WriteRequest) Tenant() (string, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.Text(), err
}

func (s WriteRequest) HasTenant() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s WriteRequest) TenantBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.TextBytes(), err
}

func (s WriteRequest) SetTenant(v string) error {
	return capnp.Struct(s).SetText(2, v)
}

// WriteRequest_List is a list of WriteRequest.
type WriteRequest_List = capnp.StructList[WriteRequest]

// NewWriteRequest creates a new list of WriteRequest.
func NewWriteRequest_List(s *capnp.Segment, sz int32) (WriteRequest_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return capnp.StructList[WriteRequest](l), err
}

// WriteRequest_Future is a wrapper for a WriteRequest promised by a client call.
type WriteRequest_Future struct{ *capnp.Future }

func (f WriteRequest_Future) Struct() (WriteRequest, error) {
	p, err := f.Future.Ptr()
	return WriteRequest(p.Struct()), err
}
func (p WriteRequest_Future) Symbols() Symbols_Future {
	return Symbols_Future{Future: p.Future.Field(0, nil)}
}

type WriteError uint16

// WriteError_TypeID is the unique identifier for the type WriteError.
const WriteError_TypeID = 0xe67be4164a39ea55

// Values of WriteError.
const (
	WriteError_none            WriteError = 0
	WriteError_unavailable     WriteError = 1
	WriteError_alreadyExists   WriteError = 2
	WriteError_invalidArgument WriteError = 3
	WriteError_internal        WriteError = 4
)

// String returns the enum's constant name.
func (c WriteError) String() string {
	switch c {
	case WriteError_none:
		return "none"
	case WriteError_unavailable:
		return "unavailable"
	case WriteError_alreadyExists:
		return "alreadyExists"
	case WriteError_invalidArgument:
		return "invalidArgument"
	case WriteError_internal:
		return "internal"

	default:
		return ""
	}
}

// WriteErrorFromString returns the enum value with a name,
// or the zero value if there's no such value.
func WriteErrorFromString(c string) WriteError {
	switch c {
	case "none":
		return WriteError_none
	case "unavailable":
		return WriteError_unavailable
	case "alreadyExists":
		return WriteError_alreadyExists
	case "invalidArgument":
		return WriteError_invalidArgument
	case "internal":
		return WriteError_internal

	default:
		return 0
	}
}

type WriteError_List = capnp.EnumList[WriteError]

func NewWriteError_List(s *capnp.Segment, sz int32) (WriteError_List, error) {
	return capnp.NewEnumList[WriteError](s, sz)
}

type Writer capnp.Client

// Writer_TypeID is the unique identifier for the type Writer.
const Writer_TypeID = 0xcc20b9c332c83b91

func (c Writer) Write(ctx context.Context, params func(Writer_write_Params) error) (Writer_write_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xcc20b9c332c83b91,
			MethodID:      0,
			InterfaceName: "pkg/receive/writecapnp/write_request.capnp:Writer",
			MethodName:    "write",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Writer_write_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Writer_write_Results_Future{Future: ans.Future()}, release

}

func (c Writer) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Writer) String() string {
	return "Writer(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Writer) AddRef() Writer {
	return Writer(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Writer) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Writer) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Writer) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Writer) DecodeFromPtr(p capnp.Ptr) Writer {
	return Writer(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Writer) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Writer) IsSame(other Writer) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Writer) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Writer) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Writer_Server is a Writer with a local implementation.
type Writer_Server interface {
	Write(context.Context, Writer_write) error
}

// Writer_NewServer creates a new Server from an implementation of Writer_Server.
func Writer_NewServer(s Writer_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Writer_Methods(nil, s), s, c)
}

// Writer_ServerToClient creates a new Client from an implementation of Writer_Server.
// The caller is responsible for calling Release on the returned Client.
func Writer_ServerToClient(s Writer_Server) Writer {
	return Writer(capnp.NewClient(Writer_NewServer(s)))
}

// Writer_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Writer_Methods(methods []server.Method, s Writer_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xcc20b9c332c83b91,
			MethodID:      0,
			InterfaceName: "pkg/receive/writecapnp/write_request.capnp:Writer",
			MethodName:    "write",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Write(ctx, Writer_write{call})
		},
	})

	return methods
}

// Writer_write holds the state for a server call to Writer.write.
// See server.Call for documentation.
type Writer_write struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Writer_write) Args() Writer_write_Params {
	return Writer_write_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Writer_write) AllocResults() (Writer_write_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Writer_write_Results(r), err
}

// Writer_List is a list of Writer.
type Writer_List = capnp.CapList[Writer]

// NewWriter_List creates a new list of Writer.
func NewWriter_List(s *capnp.Segment, sz int32) (Writer_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Writer](l), err
}

type Writer_write_Params capnp.Struct

// Writer_write_Params_TypeID is the unique identifier for the type Writer_write_Params.
const Writer_write_Params_TypeID = 0x90d5073324ecc34b

func NewWriter_write_Params(s *capnp.Segment) (Writer_write_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Writer_write_Params(st), err
}

func NewRootWriter_write_Params(s *capnp.Segment) (Writer_write_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Writer_write_Params(st), err
}

func ReadRootWriter_write_Params(msg *capnp.Message) (Writer_write_Params, error) {
	root, err := msg.Root()
	return Writer_write_Params(root.Struct()), err
}

func (s Writer_write_Params) String() string {
	str, _ := text.Marshal(0x90d5073324ecc34b, capnp.Struct(s))
	return str
}

func (s Writer_write_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Writer_write_Params) DecodeFromPtr(p capnp.Ptr) Writer_write_Params {
	return Writer_write_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Writer_write_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Writer_write_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Writer_write_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Writer_write_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Writer_write_Params) Wr() (WriteRequest, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return WriteRequest(p.Struct()), err
}

func (s Writer_write_Params) HasWr() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Writer_write_Params) SetWr(v WriteRequest) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewWr sets the wr field to a newly
// allocated WriteRequest struct, preferring placement in s's segment.
func (s Writer_write_Params) NewWr() (WriteRequest, error) {
	ss, err := NewWriteRequest(capnp.Struct(s).Segment())
	if err != nil {
		return WriteRequest{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Writer_write_Params_List is a list of Writer_write_Params.
type Writer_write_Params_List = capnp.StructList[Writer_write_Params]

// NewWriter_write_Params creates a new list of Writer_write_Params.
func NewWriter_write_Params_List(s *capnp.Segment, sz int32) (Writer_write_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Writer_write_Params](l), err
}

// Writer_write_Params_Future is a wrapper for a Writer_write_Params promised by a client call.
type Writer_write_Params_Future struct{ *capnp.Future }

func (f Writer_write_Params_Future) Struct() (Writer_write_Params, error) {
	p, err := f.Future.Ptr()
	return Writer_write_Params(p.Struct()), err
}
func (p Writer_write_Params_Future) Wr() WriteRequest_Future {
	return WriteRequest_Future{Future: p.Future.Field(0, nil)}
}

type Writer_write_Results capnp.Struct

// Writer_write_Results_TypeID is the unique identifier for the type Writer_write_Results.
const Writer_write_Results_TypeID = 0x87f6d2196d414cf4

func NewWriter_write_Results(s *capnp.Segment) (Writer_write_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Writer_write_Results(st), err
}

func NewRootWriter_write_Results(s *capnp.Segment) (Writer_write_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Writer_write_Results(st), err
}

func ReadRootWriter_write_Results(msg *capnp.Message) (Writer_write_Results, error) {
	root, err := msg.Root()
	return Writer_write_Results(root.Struct()), err
}

func (s Writer_write_Results) String() string {
	str, _ := text.Marshal(0x87f6d2196d414cf4, capnp.Struct(s))
	return str
}

func (s Writer_write_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Writer_write_Results) DecodeFromPtr(p capnp.Ptr) Writer_write_Results {
	return Writer_write_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Writer_write_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Writer_write_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Writer_write_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Writer_write_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Writer_write_Results) Error() WriteError {
	return WriteError(capnp.Struct(s).Uint16(0))
}

func (s Writer_write_Results) SetError(v WriteError) {
	capnp.Struct(s).SetUint16(0, uint16(v))
}

// Writer_write_Results_List is a list of Writer_write_Results.
type Writer_write_Results_List = capnp.StructList[Writer_write_Results]

// NewWriter_write_Results creates a new list of Writer_write_Results.
func NewWriter_write_Results_List(s *capnp.Segment, sz int32) (Writer_write_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[Writer_write_Results](l), err
}

// Writer_write_Results_Future is a wrapper for a Writer_write_Results promised by a client call.
type Writer_write_Results_Future struct{ *capnp.Future }

func (f Writer_write_Results_Future) Struct() (Writer_write_Results, error) {
	p, err := f.Future.Ptr()
	return Writer_write_Results(p.Struct()), err
}

const schema_85d3acc39d94e0f8 = "x\xda\xa4V\x7f\x88\x1cg\x19~\x9f\xef\x9b\xd9\xb9\xdc" +
	"nr7\xccRI\xb1n[\"\xf4r&Mn\x13" +
	"I\xd2\xc2\xe6b.\xe6\xd2+\xdc\xec&\xdaJ\xa2\x9d" +
	"\\\xbe\xde\x8d\x99\x9d\xdd\xce\xcc\xde\xe5NJ4 M" +
	"\xa5U\x13\x0d\xf8\x03\xa1\xd1*\xf8\xbbF\x91\x06\xaaP" +
	"#j\xf1\x07\xad\x1aPQ\xabP\x14lU\x04\x11\xc9" +
	"\x1f\x19y\xbf\xdd\x9b]\x97\x13\xb3\xe9\x7f\xb3\xcf<\xfb" +
	">\xef\xfb|\xef\xbc\xef\xb7\xedU\xb9\xd7\xd8\xbe\xfe#" +
	"9\x12\xee\x8c\x99K\xff93Y\xdf\xf8\xf3\x7f=F" +
	"\xee\x04@dXD\xe5-R\x08\x823)+\x84\xf4" +
	"\xbe+\xafm*[W?J\xf6\x04\x88L0\xc1\x93" +
	"\xd7@pZ\x9a\xf0\xb5w\x8f}\xec\xa5\xe9\xb7~\x82" +
	"\xdcq \xfd\xf7\x1f>\xfe\x99+_\xf9\xc5\x07\xdb\x91" +
	".\xc8Kp\xbe*-\"\xe7\x8br\x89\x90>vy" +
	"\xf7-\x17^|\xe8s\xe4\xee\x84\x95n\xde\xf5\x8e3" +
	"S\xf7\xfe\xee\xfbt$gA\xc0(\x9b\xc6o8\xf0" +
	"F\x83\xb9+\xcf^\x7f\xed\x0b\x7f\\\xfe2\xd9\xe3=" +
	"q\xdb\x19<j|\x0a\xce\x05\xd6p\xce\x19\x9c\xc5\x86" +
	"\x1d\xcb\x9f~\xff\xc5\xe4\x9bk\x066\xcb\xcf\x1b:\xe3" +
	"\xab:\xf0\x81\xe4\xf2]\xe2\xf9]\xdf\xea\x0b\xac3\xde" +
	"m^\x82\xe3\x9a\x1c\xf8~\xf3\xcf\x84\xf4\xbb\x87?\xb9" +
	"\xfbv\x9c\xf9\x0e\x97'\xfa\xd3\xf0s\x9f\x85\xf3\x81\x1c" +
	"\xb3\x1f\xcd}\x9d\xd0\x15v\xc7a\xf5\xb0\x99R\x1e\xb3" +
	"\xbe\x04g\xd2z\x03Q\xf9~\xebeAH\xcf\xdd\xf3" +
	"\xa3\x89+\x97o\xff\x09\xd9\xe3\xb2\xcb&\x94\x9f\x1c>" +
	"\x0f\xe7\xf3\xc3\x1c\xf8\xe2\xf0\xdb\x9d\x17\xf8)}\xe6M" +
	"\xfb\x0f\xfc\xe0g\xcf\\%{\xa7\xe8*\x11\xca\xdf\x18" +
	"\xbe\x06\xe7\xa7\x9a\xfd\xc2\xf0<!=\xf2\x97\xdd\x87n" +
	"y\xe5}\x7f\"{\\\xfcW\xdc\xbf\x0e_\x82c\xe6" +
	"\x99\x89\xfci.\xef\xdb\x1f.,\xfd\xf8\x9eW\xfb\xbc" +
	"\xe0#+O\xe5\xbf\x07\xe7\x98&?\x98\xe7\xea~\xdf" +
	":{-xy\xfa\xef}^h\xe3\xcc\xc2y8\xb7" +
	"\x15\x98\xbc\xb1\xc0.O\xdcg[\x7f\xfb\xe1\xf9\x7f\xac" +
	"\xd5\x17\xcb\x85\x0f\xc19\xa7\xc9O\x16\x96hK\xda<" +
	"9\x7fw\xa4\xe6\x94\xe5/\xaa\xbb\x97\"?Qs^" +
	"3l\xb6\x1f\xdf\x13\xa9GZ*N\xb6jl\xcf;" +
	"\x19\x8b\xb6\xeaW\x9b\xaa*n\x05IL\xae!\x0d\"" +
	"\x03D\xf6\xfa\x09\"wH\xc2-\x0a\x94T\x145\"" +
	"\x8ct\x1d!`\x84\x90\x09\xe6\x06\x15\xac\xccz\x91W" +
	"\x8f{\xf5n\xed\xea\xc9\xa5\x08\xa3]S\x09\x18\xed\x11" +
	"3o@l_k\xee\xa4*%\xb5\xa6\x17\xce\x02\xee" +
	"P&3\xb6\x87\xc8\xdd$\xe1n\x13\xb0\x81\"\x7f\xae" +
	"\xf6\x16\x06\xef\x92pw\x08T\x1a\x0f?\x1c\xab\x04\x06" +
	"\x09\x18\x84J\xa0\xc2\xf9d\x01C$04`\xc5\x07" +
	"\xfd8i\xccG^}\xeb\\\xa3%\xc3\x84\xd3(\xa4" +
	"i;\x8fC]\xc9\xf5\xb8\x9e\xb6\x13\xd9\xfe.\"w" +
	"\x9b\x84{\xaf@:\xd7h\x85\xc9t\x98\x10\x11\xd6\x91" +
	"\xc0:\xea`\x07\x82\x06I/A\x9e\x04\xf2\x03\x1aS" +
	"[\xae\x1fo\xc8 fW\xd68\xecM\x02%?Q" +
	"\xf5\x18\x1b\x08\xb3\x12(\x90\xe0\xc7\x9b\xac{EE\x95" +
	"\xc6\xdb8g\xae\xfd\x8dij\x14ar\xf5\xef\xedV" +
	"\x7f\x1b\xae3\x9c\xe3\xf2Wz\xca_Q\x91\xfe+\x8d" +
	"\xb0\x09\x99\x03\x19\\a\x1fn\xd2\x85\xc3~]\xd5J" +
	"*\xf2\x956b43\xc2\xe3N8*\xe1\x9e\xeai" +
	"\x8f\xd6>\"\xb7)\xe1>!`\x0bQ\x84 \xb2\x1f" +
	"\xe7\xa3:+\xe1>-`KY\x84$\xb2/V\x89" +
	"\xdc\xa7$\xdc\xe7\x04*\x81w\\\x05\x99\x91\xa3\xddO" +
	"\x99\xc0\xe0\xe9\xd8\xab7\x03\xd5C\xc8\x06C\x9b\x90." +
	"t|$Y\xefa\xf5\x8c,\xcdR\xa7T\xbd\x19x" +
	"\x11\xa1\x87\x94\xcd\xdb\x0ei\x10s\xa68\xa0\x15x\x11" +
	"[S\xc8\xac\x99bk\xf6J\xb8G\x05V\x9dy\x90" +
	"\xfb\xe6\xb0\x84\xfb\x10;\x83\xb63\xc7\xaa\x1d\x0f\x17\xfe" +
	"\xbf\x09\xa5E/h\xa9\xec\x0c\x13\xbf\xae\xe2\xc4\xab\x13" +
	"\x9a0I\xc0\x1c0u\xddy#\xdcz\xae\x01\xf4\x8c" +
	"zT\xd3\xaa\x8aUr\xd0\x0f\x09\x89\xbb\x83\xabB\xcf" +
	"\"u\x8ea\x82\x84\x8d\xf6\xe1:S\xb8\x93\xa8\xb6\x17" +
	"\x12\xb5\x19pi\xed\xf3u\xa6\xb1\x87\xa8\xb6\x9f\xf1Y" +
	"t\xce\xdd\xe0%\x87\x88\xa86\xc3\xf8\x03\x10\x00\x8bg" +
	"\xbb\xd49\x82*\xd7R\xe4e\xe7Lj\xaa\x0e}\x94" +
	"C\xe4P\xc4\x10\xef\x06\xac\x10\xd5\x1e`<a\xdc\x12" +
	"E\xac#r\x1e\xd1x\x93\xf1'\x18\x1f\x92E\x0c\x13" +
	"9\x8f\xeb8g\x19\x7f\x9a\xf1uF\x11y^t\x9a" +
	"\xff\x14\xe3\xcf1>l\x16Q r.k\xfcY\xc6" +
	"\x7f\xc9x\xbeX\xc4z\"\xe7%T\x89j/2\xfe" +
	"[\xc6\x0b\xb9\"6\x109\xbf\xd6\xf8\xaf\x18\x7f\x05\x02" +
	"%=y\xac\xb8U_=\xacJ<\xb7\xa0\xea\xde\xea" +
	"\xa0\xd4\x1f\xe6\xe1\x85HQ)^h\x04'\xb23\xcd" +
	">X$i\xa8\xe6\xbd\xc4_TT\xe2\xc9\xdc\xd3\x16" +
	"\xd9\xf5\xa7\xd3\xaf\x19\xb1\xb2_\x05\x89\x971\xcd\xce8" +
	"\xea\xbe\xd7\xd3%{\x9f_\x1dW\x8d\xd8\xbf!\xa1\x8c" +
	"\xf8?\x84\xba\xef\xd7\x16\x8a\xba]\x85\x91n\xc3u\xf6" +
	"\xe3\xeb\xedg\xbd3\x11\xb5\x87\xb5I\x94\xdd#\xb1z" +
	"\xe3\xb4m\xee[\xd3*\xe9\xbf\xef\xc5,nvVW" +
	"U\\\xd1\xa5$z$\xeaOyl\x1fWb\xdfq" +
	"'\x11\x84\xbd\xf1V\"HV\xa4\xd3\xad\xf0d\xd8X" +
	"\x0a\xade\x15\xcb\xb0Q\x9a\xf7Z\xf3j\xf0\xd2JS" +
	"|\xb1`\xbd\xf6\xe8\xd8\xb9Y\xebm9\xae\xf5\xc6\"" +
	"\xad\xf7\xe63D0\xec;\x0e\x11\x8d\x84\x8dP\xa5\xad" +
	"\xd0[\xf4\xfc\xc0#\xebx\xa0R/\x88\x94wby" +
	"\x8aJ\xa7\xfc8\x89S?\\\xf4\x02\xff\xc4\xa4\x88\xe6" +
	"[u\x15&\xe4\x87\x89\x8aB/ \x1a\xfc\xbeRm" +
	"C\xd47\x0a\xf7uF\xe1L\xcf\x96\x98\xe6\x85pP" +
	"\xc2=\xd1\xb3%\xb2}\xb2 p:\xe6\xdd\x1b\xc4\x18" +
	"\xed^\xca;W\x1b\xee\x93\x9a\x8a|\x92\xbd\xfb \xbb" +
	"a\xb7{\xb5\x92\xa8\xd0\x0b\x13\xbd\x92\x0b\x83\xae}\xde" +
	"5P}w\xa1jw\x0bgel\xe7\x91\xfe\x16\x09" +
	"w\x97X\xb3\x7f\xfb&\xf6 I\xcc\xf0. \xeaK" +
	"b\xf3Z\x17\xb2\x89nf#\xa1WW\xab\xf7\xaf\x8e" +
	"z\xe7\xd7\x7f\x02\x00\x00\xff\xff\x91\x1c\xa7\x12"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_85d3acc39d94e0f8,
		Nodes: []uint64{
			0x87f6d2196d414cf4,
			0x90d5073324ecc34b,
			0x983649d193295eae,
			0xa360d0951639b987,
			0xab79e1a6ecfeb87a,
			0xb374a1809b79340e,
			0xb438c10228b97446,
			0xbd820120399954be,
			0xc4dd3c458256382a,
			0xcc20b9c332c83b91,
			0xd5b0cec646441eb0,
			0xe67be4164a39ea55,
			0xeb3bcb770c8eb6be,
			0xef49df6cfa8875de,
			0xf192c7ee07114b32,
		},
		Compressed: true,
	})
}
